{% comment %}
PAPS Tabulator Table Component
- Reusable table component for PAPS measurement data entry
- Supports complex multi-level headers using Column Groups
- Integrates with existing measurement_schema structure
- Preserves all current functionality (calculations, validation, batch operations)
{% endcomment %}

<!-- Include Tabulator setup -->
{% include 'physical_education/includes/tabulator_setup.html' %}

<script>
// PAPS Tabulator namespace
if (!window.PAPSTabulator) {
    window.PAPSTabulator = {};
}

// PAPS Tabulator configuration
window.PAPSTabulator.config = {
    ...window.PETabulator.defaultConfig,
    layout: "fitColumns", // Scale columns to fit table width
    responsiveLayout: "collapse",
    responsiveLayoutCollapseStartOpen: false,
    pagination: false, // Load all students at once as per requirement
    maxHeight: "70vh",
    columnCalcs: "table",
    editTriggerEvent: "click",
    validationMode: "blocking",
    placeholder: "측정 데이터가 없습니다.",
    
    // Korean localization
    langs: {
        "ko-kr": {
            ...window.PETabulator.defaultConfig.langs["ko-kr"],
            "pagination": {
                "page_size": "페이지 크기",
                "page_title": "페이지 번호",
                "first": "처음",
                "first_title": "첫 페이지",
                "last": "마지막",
                "last_title": "마지막 페이지",
                "prev": "이전",
                "prev_title": "이전 페이지",
                "next": "다음",
                "next_title": "다음 페이지",
                "all": "전체"
            },
            "ajax": {
                "loading": "측정 데이터 로딩중...",
                "error": "데이터 로딩 오류"
            },
            "groups": {
                "item": "항목",
                "items": "항목들"
            },
            "columns": {
                "name": "이름"
            },
            "data": {
                "loading": "로딩중...",
                "error": "오류"
            }
        }
    },
    locale: "ko-kr"
};

// Build column definitions from measurement schema with Column Groups support
window.PAPSTabulator.buildColumns = function(activity, students) {
    if (!activity || !activity.measurement_schema || !activity.measurement_schema.fields) {
        return [];
    }
    
    const schema = activity.measurement_schema;
    const fields = schema.fields || [];
    
    // Base columns (student info) - always frozen
    const baseColumns = [
        {
            title: "순번",
            field: "_index",
            widthGrow: 1,
            minWidth: 50,
            hozAlign: "center",
            resizable: true,
            frozen: true,
            formatter: function(cell) {
                return cell.getRow().getPosition();
            }
        },
        {
            title: "번호",
            field: "number",
            widthGrow: 1.5,
            minWidth: 60,
            hozAlign: "center",
            resizable: true,
            frozen: true,
            formatter: function(cell) {
                const value = cell.getValue();
                return value || '-';
            }
        },
        {
            title: "성명",
            field: "name",
            widthGrow: 2,
            minWidth: 80,
            hozAlign: "center",
            resizable: true,
            frozen: true,
        },
        {
            title: "성별",
            field: "gender",
            widthGrow: 1,
            minWidth: 50,
            hozAlign: "center",
            resizable: true,
            frozen: true,
            formatter: function(cell) {
                const value = cell.getValue();
                return value === 'M' ? '남' : (value === 'F' ? '여' : '-');
            }
        }
    ];
    
    // Analyze fields for grouping patterns
    const fieldGroups = window.PAPSTabulator.analyzeFieldGroups(fields);
    
    // Build measurement and calculated columns with groups
    const measurementColumns = window.PAPSTabulator.buildGroupedColumns(fieldGroups.measurement, activity);
    const calculatedColumns = window.PAPSTabulator.buildGroupedColumns(fieldGroups.calculated, activity);
    
    // Result columns
    const resultColumns = [
        {
            title: "점수",
            field: "score",
            widthGrow: 1.5,
            minWidth: 60,
            hozAlign: "center",
            resizable: true,
            cssClass: "calculated-field",
            formatter: function(cell) {
                // This would be calculated based on measurement data
                // For now, using placeholder
                return '-';
            }
        },
        {
            title: "등급", 
            field: "grade",
            widthGrow: 1.5,
            minWidth: 70,
            hozAlign: "center",
            resizable: true,
            cssClass: "calculated-field",
            formatter: function(cell) {
                // This would be calculated based on score
                // For now, using placeholder with grade styling
                const grade = Math.floor(Math.random() * 5) + 1; // Temporary
                return `<span class="grade-${grade}">${grade}등급</span>`;
            }
        }
    ];
    
    return [...baseColumns, ...measurementColumns, ...calculatedColumns, ...resultColumns];
};

// Analyze fields to identify grouping patterns
window.PAPSTabulator.analyzeFieldGroups = function(fields) {
    const measurement = [];
    const calculated = [];
    const groups = new Map();
    
    fields.forEach(field => {
        const isCalculated = field.readonly;  // Use schema readonly property directly
        const targetArray = isCalculated ? calculated : measurement;
        
        // Check for grouping patterns in field names
        const groupMatch = window.PAPSTabulator.identifyGroup(field);
        
        if (groupMatch) {
            // Field belongs to a group
            if (!groups.has(groupMatch.groupName)) {
                groups.set(groupMatch.groupName, {
                    name: groupMatch.groupName,
                    title: groupMatch.groupTitle,
                    fields: [],
                    isCalculated: isCalculated
                });
            }
            groups.get(groupMatch.groupName).fields.push(field);
        } else {
            // Individual field
            targetArray.push({
                type: 'individual',
                field: field
            });
        }
    });
    
    // Add groups to appropriate arrays
    groups.forEach(group => {
        const targetArray = group.isCalculated ? calculated : measurement;
        targetArray.push({
            type: 'group',
            group: group
        });
    });
    
    return { measurement, calculated };
};

// Identify group patterns in field names
window.PAPSTabulator.identifyGroup = function(field) {
    const fieldName = field.name || '';
    const fieldTitle = field.title || field.label || '';
    
    // Pattern matching for common groupings
    const patterns = [
        // Flexibility patterns (어깨_좌, 어깨_우, etc.)
        { regex: /^(어깨|몸통|옆구리|하체)_?(좌|우|left|right)$/i, 
          groupExtractor: (match) => ({ 
              groupName: match[1], 
              groupTitle: match[1],
              subField: match[2] 
          })
        },
        // Grip strength patterns (오른쪽1차, 왼쪽1차, etc.)
        { regex: /^(오른쪽|왼쪽|right|left)_?(\d차|attempt\d?)$/i,
          groupExtractor: (match) => ({
              groupName: '악력',
              groupTitle: '악력',
              subField: `${match[1]}_${match[2]}`
          })
        },
        // Multi-attempt patterns (1차, 2차, etc.)
        { regex: /^(.+)_?(\d차|attempt\d?)$/i,
          groupExtractor: (match) => ({
              groupName: match[1],
              groupTitle: match[1],
              subField: match[2]
          })
        },
        // Heart rate patterns (심박수1, 심박수2, etc.)
        { regex: /^(심박수|hr|heart_rate)_?(\d+)$/i,
          groupExtractor: (match) => ({
              groupName: '심박수',
              groupTitle: '심박수',
              subField: match[2]
          })
        }
    ];
    
    // Try to match patterns
    for (const pattern of patterns) {
        const match = fieldName.match(pattern.regex) || fieldTitle.match(pattern.regex);
        if (match) {
            return pattern.groupExtractor(match);
        }
    }
    
    return null;
};

// Build grouped columns with Column Groups support
window.PAPSTabulator.buildGroupedColumns = function(items, activity) {
    const columns = [];
    
    items.forEach(item => {
        if (item.type === 'individual') {
            // Individual column
            const column = window.PAPSTabulator.buildSingleColumn(item.field, activity);
            columns.push(column);
        } else if (item.type === 'group') {
            // Group of columns
            const group = item.group;
            const groupColumns = group.fields.map(field => 
                window.PAPSTabulator.buildSingleColumn(field, activity)
            );
            
            // Create Column Group
            const columnGroup = {
                title: group.title,
                cssClass: "header-group",
                columns: groupColumns
            };
            
            columns.push(columnGroup);
        }
    });
    
    return columns;
};

// Build a single column definition using schema data directly
window.PAPSTabulator.buildSingleColumn = function(field, activity) {
    // Determine appropriate widthGrow and minWidth based on field type and content
    let widthGrow = 2; // Default growth factor
    let minWidth = 80;
    
    if (field.type === 'decimal') {
        widthGrow = 2.5; // More space for decimal numbers
        minWidth = 90;
    } else if (field.type === 'boolean') {
        widthGrow = 1.5; // Less space for checkboxes
        minWidth = 60;
    } else if (field.title && field.title.length > 10) {
        widthGrow = 3; // More space for long titles
        minWidth = 100;
    }
    
    // Use schema data directly
    const baseColumn = {
        title: field.title,  // Use schema title directly
        field: `measurement_data.${field.field}`,  // Use schema field property
        widthGrow: widthGrow,
        minWidth: minWidth,
        hozAlign: "center",
        resizable: true,
        tooltip: field.title
    };
    
    // Use field.readonly from schema to determine column type
    if (field.readonly) {
        // Calculated/readonly column
        return {
            ...baseColumn,
            cssClass: "calculated-field",
            formatter: function(cell) {
                const value = cell.getValue();
                if (value === null || value === undefined || value === '') {
                    return '-';
                }
                
                // Format based on field type and schema properties
                if (field.type === 'decimal' && field.decimal_places !== undefined) {
                    const formatted = parseFloat(value).toFixed(field.decimal_places);
                    return field.unit ? `${formatted} ${field.unit}` : formatted;
                }
                
                if (field.type === 'boolean') {
                    return value ? '○' : '×';
                }
                
                // Add unit if specified
                return field.unit ? `${value} ${field.unit}` : value;
            }
        };
    } else {
        // Input column
        return {
            ...baseColumn,
            editor: window.PAPSTabulator.getFieldEditor(field),
            validator: window.PAPSTabulator.getFieldValidator(field),
            formatter: function(cell) {
                const value = cell.getValue();
                if (value === null || value === undefined || value === '') {
                    return '';
                }
                
                // Format based on field type and schema properties
                if (field.type === 'decimal' && field.decimal_places !== undefined) {
                    const formatted = parseFloat(value).toFixed(field.decimal_places);
                    return field.unit ? `${formatted} ${field.unit}` : formatted;
                }
                
                if (field.type === 'boolean') {
                    return value ? '○' : '×';
                }
                
                // For input fields, don't show unit in the cell (it can be in placeholder or label)
                return value;
            },
            cellEdited: function(cell) {
                window.PAPSTabulator.onCellEdited(cell, field, activity);
            }
        };
    }
};

// Get appropriate editor for field type
window.PAPSTabulator.getFieldEditor = function(field) {
    switch (field.type) {
        case 'integer':
        case 'decimal':
            return "number";
        case 'boolean':
            return "tickCross";
        case 'string':
        default:
            return "input";
    }
};

// Get validator for field
window.PAPSTabulator.getFieldValidator = function(field) {
    const validators = [];
    
    if (field.required) {
        validators.push("required");
    }
    
    if (field.type === 'integer' || field.type === 'decimal') {
        validators.push("numeric");
        
        if (field.min !== undefined) {
            validators.push({type: "min", parameters: field.min});
        }
        
        if (field.max !== undefined) {
            validators.push({type: "max", parameters: field.max});
        }
    }
    
    return validators;
};

// Handle cell edited event
window.PAPSTabulator.onCellEdited = function(cell, field, activity) {
    const row = cell.getRow();
    const studentId = row.getData().id;
    const fieldName = field.name;
    const value = cell.getValue();
    
    // Save data to app state (preserve existing functionality)
    if (window.saveStudentFieldData) {
        window.saveStudentFieldData(studentId, fieldName, value);
    }
    
    // Trigger calculations (preserve existing functionality)
    if (window.performAutoCalculation) {
        window.performAutoCalculation(studentId);
    }
    
    // Set dirty flag
    if (window.appState) {
        window.appState.isDirty = true;
    }
    
    // Update calculated fields in the table
    window.PAPSTabulator.updateCalculatedFields(row, activity);
};

// Update calculated fields in a row
window.PAPSTabulator.updateCalculatedFields = function(row, activity) {
    if (!activity || !activity.measurement_schema) return;
    
    const studentId = row.getData().id;
    const studentData = window.appState?.studentsData?.[studentId];
    if (!studentData || !studentData[activity.id]) return;
    
    const activityData = studentData[activity.id];
    const schema = activity.measurement_schema;
    
    schema.fields.forEach(field => {
        if (field.readonly || field.calculated) {
            const calculatedValue = activityData[field.name];
            if (calculatedValue !== undefined) {
                // Update the cell value
                const cell = row.getCell(`measurement_data.${field.name}`);
                if (cell) {
                    cell.setValue(calculatedValue);
                }
            }
        }
    });
    
    // Update score and grade if calculation logic exists
    // This would integrate with existing evaluation criteria
};

// Transform student data for Tabulator
window.PAPSTabulator.transformStudentData = function(students, activity) {
    if (!students || !Array.isArray(students)) return [];
    
    return students.map(student => {
        const measurementData = student.measurement_data || {};
        
        return {
            id: student.id,
            number: student.number,
            name: student.name,
            gender: student.gender,
            measurement_data: measurementData,
            score: null, // Will be calculated
            grade: null,  // Will be calculated
            evaluation_grade: student.evaluation_grade || null,
            measured_at: student.measured_at || null,
            notes: student.notes || "",
            record_id: student.record_id || null
        };
    });
};

// Build Ajax URL for data loading
window.PAPSTabulator.buildAjaxURL = function(sessionId, activityId, classId, grade) {
    const baseUrl = '/physical_education/api/paps/measurements/by-activity/';
    
    // Convert all parameters to strings to ensure consistency
    const params = new URLSearchParams({
        session_id: String(sessionId),
        activity_id: String(activityId),
        class_id: String(classId),
        grade: String(grade)
    });
    
    const fullUrl = `${baseUrl}?${params.toString()}`;
    console.log('생성된 Ajax URL:', fullUrl);
    
    return fullUrl;
};

// Ajax response processor
window.PAPSTabulator.ajaxResponseProcessor = function(url, params, response) {
    console.log('Ajax 응답 처리 시작:', { url, params, response });
    
    // Check if response is valid
    if (!response) {
        console.error('응답이 null 또는 undefined');
        throw new Error('서버에서 응답을 받지 못했습니다.');
    }
    
    if (!response.success) {
        console.error('API 호출 실패:', response.error);
        throw new Error(response.error || 'API 호출에 실패했습니다.');
    }
    
    if (!response.students || !Array.isArray(response.students)) {
        console.error('학생 데이터가 올바르지 않음:', response.students);
        throw new Error('올바르지 않은 학생 데이터 형식입니다.');
    }
    
    console.log(`${response.students.length}명의 학생 데이터 처리 중...`);
    
    // Transform the server response to Tabulator format
    const transformedData = window.PAPSTabulator.transformStudentData(response.students);
    console.log('변환된 테이블 데이터:', transformedData);
    
    return transformedData;
};

// Initialize PAPS Tabulator table with Ajax support
window.PAPSTabulator.init = function(containerId, activity, options = {}, sessionData = {}) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error('Container not found:', containerId);
        return null;
    }
    
    // Check if we have the required state for Ajax loading
    // Use sessionData first, fallback to window.appState
    const selectedSession = sessionData.selectedSession || window.appState?.selectedSession;
    const selectedClass = sessionData.selectedClass || window.appState?.selectedClass;
    const selectedGrade = sessionData.selectedGrade || window.appState?.selectedGrade;
    
    const requiredFields = {
        useAjax: options.useAjax,
        selectedSession: selectedSession,
        selectedClass: selectedClass,
        selectedGrade: selectedGrade,
        activityId: activity?.id,
        sessionDataProvided: Object.keys(sessionData).length > 0,
        windowAppStateAvailable: !!window.appState
    };
    
    console.log('Ajax 조건 체크:', requiredFields);
    
    const useAjax = options.useAjax && 
                   selectedSession && 
                   selectedClass && 
                   selectedGrade &&
                   activity?.id;
    
    console.log('Ajax 모드 사용 여부:', useAjax);
    
    // Build columns
    const columns = window.PAPSTabulator.buildColumns(activity, []);
    
    let config = {
        ...window.PAPSTabulator.config,
        ...options,
        columns: columns
    };
    
    if (useAjax) {
        // Ajax-based configuration
        const ajaxURL = window.PAPSTabulator.buildAjaxURL(
            selectedSession,
            activity.id,
            selectedClass,
            selectedGrade
        );
        
        config.ajaxURL = ajaxURL;
        config.ajaxConfig = {
            method: 'GET',
            headers: {
                'X-CSRFToken': window.djangoData?.csrfToken || document.querySelector('[name=csrfmiddlewaretoken]')?.value || '',
                'Content-Type': 'application/json'
            }
        };
        config.ajaxRequesting = function() {
            console.log('Ajax 데이터 로딩 시작...', ajaxURL);
        };
        config.ajaxResponse = function(url, params, response) {
            console.log('Ajax 데이터 로딩 완료:', response);
            return window.PAPSTabulator.ajaxResponseProcessor(url, params, response);
        };
        config.ajaxError = function(xhr, textStatus, errorThrown) {
            console.error('Tabulator Ajax 오류:', {
                status: xhr.status,
                statusText: xhr.statusText,
                errorThrown: errorThrown,
                url: ajaxURL
            });
            if (window.showMessage) {
                window.showMessage('error', '측정 데이터 로딩 중 오류가 발생했습니다.');
            }
        };
    } else {
        // Fallback to empty data for manual loading
        console.log('Ajax 모드가 아닙니다. 빈 데이터로 테이블 초기화합니다.');
        config.data = [];
        config.placeholder = "조회 버튼을 클릭하여 학생 데이터를 불러오세요.";
    }
    
    // Create table
    const table = new Tabulator(`#${containerId}`, config);
    
    // Register for responsive updates
    if (!window.tabulatorInstances) {
        window.tabulatorInstances = [];
    }
    window.tabulatorInstances.push(table);
    
    return table;
};

// Update table data with Ajax reload
window.PAPSTabulator.reloadData = function(table, sessionId, activityId, classId, grade) {
    if (!table) return Promise.reject(new Error('Table not found'));
    
    const ajaxURL = window.PAPSTabulator.buildAjaxURL(sessionId, activityId, classId, grade);
    
    // Use setData with URL to trigger Ajax reload
    return table.setData(ajaxURL)
        .then(() => {
            console.log('테이블 데이터 새로고침 완료');
            return table;
        })
        .catch(error => {
            console.error('테이블 데이터 새로고침 실패:', error);
            throw error;
        });
};

// Legacy update function for backward compatibility
window.PAPSTabulator.updateData = function(table, students, activity) {
    if (!table) return;
    
    const data = window.PAPSTabulator.transformStudentData(students, activity);
    table.setData(data);
};

// Get all table data for batch operations
window.PAPSTabulator.getAllData = function(table) {
    if (!table) return [];
    
    return table.getData();
};

// Clear all measurement data
window.PAPSTabulator.clearAllData = function(table, activity) {
    if (!table || !activity) return;
    
    const data = table.getData().map(row => {
        return {
            ...row,
            measurement_data: {},
            score: null,
            grade: null
        };
    });
    
    table.setData(data);
};

console.log('PAPS Tabulator component loaded successfully');
</script>

<style>
/* PAPS Tabulator specific styles - Minimal approach using Bootstrap 5 theme */
.paps-tabulator-container {
    width: 100%;
}

.paps-tabulator-container .tabulator {
    font-size: 12px;
    width: 100%;
}

/* Essential custom styles only */

/* Header text alignment - Center align all header titles */
.paps-tabulator-container .tabulator-col-title {
    text-align: center;
}

/* Grade colors - Custom functionality not in Bootstrap theme */
.paps-tabulator-container .grade-1 { color: #dc2626; font-weight: bold; }
.paps-tabulator-container .grade-2 { color: #ea580c; font-weight: bold; }
.paps-tabulator-container .grade-3 { color: #ca8a04; font-weight: bold; }
.paps-tabulator-container .grade-4 { color: #16a34a; font-weight: bold; }
.paps-tabulator-container .grade-5 { color: #2563eb; font-weight: bold; }

/* Input field focus enhancement */
.paps-tabulator-container .tabulator-cell input:focus {
    background: #eff6ff;
    outline: 1px solid #3b82f6;
    border-radius: 2px;
}

/* Validation error styling - Important for user feedback */
.paps-tabulator-container .tabulator-validation-fail {
    border: 2px solid #ef4444 !important;
    background: #fef2f2 !important;
}

.paps-tabulator-container .tabulator-validation-fail input {
    color: #dc2626;
}
</style>